# 一、页面环境搭建
````
1、复制confirm.html、createForWxNative.html、detail.html、list.html、pay.html 到订单服务

2、把 resource/静态资源/html/static/order 复制到 到 /mydata/nginx/html/static

3、修改 C:\Windows\System32\drivers\etc 下的 hosts文件
添加映射
192.168.48.129(虚拟机ip) order.gulimall.com

4、网关配置路由
- id: gulimall_order_route
  uri: lb://gulimall-order
  predicates:
    - Host=order.gulimall.com
    
5、加入注册中心、开启远程调用

6、thymeleaf依赖、关缓存

7、订单服务写 {page}.html接口用来跳转页面

8、测试访问
````
# 二、整合Spring Session
````
1、导入Spring Session、Redis、jedis依赖

2、引导类开启Spring Session

3、配置文件配置redis地址、Spring Session存储方式

4、复制 商品服务的GulimallSessionConfig 到订单服务
````
# 三、整合线程池
````
1、复制商品服务的 线程池配置 到订单服务下

2、yml自定义线程池属性
````
# 四、订单分析
## 1、订单状态
````
1、待付款
用户提交订单后， 订单进行预下单， 目前主流电商网站都会唤起支付， 便于用户快速完成支付， 需要注意的是待付款状态下可以对库存进行锁定， 锁定库存需要配置支付超时时间， 超时后将自动取消订单， 订单变更关闭状态。
2、已付款/待发货
用户完成订单支付， 订单系统需要记录支付时间， 支付流水单号便于对账， 订单下放到 WMS系统， 仓库进行调拨， 配货， 分拣， 出库等操作。
3、待收货/已发货
仓储将商品出库后， 订单进入物流环节， 订单系统需要同步物流信息， 便于用户实时知悉物品物流状态
4、已完成
用户确认收货后， 订单交易完成。 后续支付侧进行结算， 如果订单存在问题进入售后状态
5、已取消
付款之前取消订单。 包括超时未付款或用户商户取消订单都会产生这种订单状态。
6、售后中
用户在付款后申请退款， 或商家发货后用户申请退换货。售后也同样存在各种状态， 当发起售后申请后生成售后订单， 售后订单状态为待审核， 等待商家审核， 商家审核通过后订单状态变更为待退货， 等待用户将商品寄回， 商家收货后订单状态更新为待退款状态， 退款到用户原账户后订单状态更新为售后成功。
````
## 2、订单流程
![本地路径](../../img/note/订单流程.PNG)
# 五、订单登录拦截
````
1、订单服务的OrderWebController 编写/toTrade接口 用来跳转页面

2、登录拦截器,HandlerInterceptor 

3、WebMvcConfigurer 配置类添加拦截器
````
# 六、订单确认页
## 1、接口编写
````
1、新建vo 
OrderConfirmVo 订单确认页需要的数据
MemberAddressVo 用户收获地址
OrderItemVo 所有选中的购物项

2、会员模块 写/member/memberreceiveaddress/{memberId}/address 获取会员所有收货地址

3、商品模块 写/product/skuinfo/{skuId}/price 获取指定商品的价格

4、购物车模块 写/currentUserCartItems 
远程调用商品模块 获取指定商品的价格
最终获取用户选择的所有CartItem

5、订单服务写 /toTrade 
远程调用会员模块 获取会员所有收货地址
远程调用购物车模块 获取用户选择的所有CartItem
最后返回订单确认页需要的数据
````
## 2、Feign远程调用丢失请求头问题
![本地路径](../../img/note/Feign远程调用丢失请求头问题.PNG)
````
问题: Feign远程调用的时候会丢失请求头

原因: 远程调用是一个新的请求，不携带之前请求的cookie，导致购物车服务得不到请求头cookie里的登录信息。

解决: 订单服务 配置类添加请求拦截器 GulimallFeignConfig
因为feign在远程调用之前会执行所有的RequestInterceptor拦截器
````
## 3、异步线程丢失主线程请求头问题
![本地路径](../../img/note/异步线程丢失主线程请求头问题.PNG)
````
由于 RequestContextHolder底层使用的是线程共享数据 ThreadLocal<RequestAttributes>，我们知道线程共享数据的域是 当前线程下, 线程之间是不共享的。所以在开启异步后，异步线程获取不到主线程请求的信息，自然也就无法共享cookie了。

解决: 向异步 RequestContextHolder 线程域中放主线程的域。
````
## 4、商品的库存查询
````
1、订单服务 新建SkuStockVo 是否有库存

2、OrderConfirmVo 新增属性 Map<Long, Boolean> stocks

3、在订单确认页数据获取 Service层实现类 OrderServiceImpl 方法中远程调用库存模块批量查询库存
````
## 5、根据用户地址ID，返回详细地址并计算物流费
````
1、复制订单服务下的 MemberAddressVo 到 库存服务

2、库存服务 新建 FareVO

3、库存服务写/ware/wareinfo/fare接口 
远程调用会员服务 查询收货地址
根据用户地址，返回详细地址并计算物流费
````
# 七、保证接口幂等性，防重复提交表单
## 1、幂等性概述
````
1、接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的。

2、接口幂等性
接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用，比如说支付场景，用户购买了商品支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也交成了两条这就没有保证接口的幂等性。

3、哪些情况需要防止
    用户多次点击按钮
    用户页面回退再次提交
    微服务互相调用，由于网络问题，导致请求失败。feign 触发重试机制
    其他业务情況
    
4、幂等性解决方案
    1、token机制（令牌机制）本项目采用令牌机制
    2、各种锁机制
    3、各种唯一性约束
    4、防重表
    5、全局请求唯一id
````
## 2、任务幂等性的三种保证方法
````
数据库约束：比如唯一约束，主键。同一个主键不可能两次都插入成功。不推荐因为适用范围太窄，只适用于保存数据库前就已经设置好主键并且每次主键一样的情况下。

乐观锁：数据库表中增加一个版本字段，更新时判断是否等于某个版本。例如重复提交时判断数据库发现版本已被改变就不提交了。不推荐，因为要查数据库，给数据库压力，临时的操作我们尽量在缓存库里操作，降低数据库压力。

Redis唯一序列号（推荐）：Redis键为任务id，值为随机序列化uuid。请求前生成唯一的序列号，携带序列号去请求，请求时在redis记录该序列号表示以该序列号的请求执行过了，如果相同的序列号再次来执行说明是重复执行。也可以通过让用户每次提交时输入验证码，提交后校验前后端验证码实现幂等性。
````
## 3、代码实现，防重复提交表单，唯一序列号方式保证幂等性
````
1、修改 orderService.orderConfirm 确认订单时服务器和浏览器都保存一份防重令牌

2、新建OrderSubmitVo 封装订单提交数据, SubmitOrderResponseVo 封装下订单后返回的数据, 写 /submitOrder接口 下订单时验证令牌
````
# 八、提交订单
````
1、订单服务创建 OrderCreateTo

2、订单服务创建枚举类 OrderConstant

3、复制库存服务的 FareVO 到 订单服务下

4、公共服务新建 OrderStatusConstant

5、商品服务编写 /product/spuinfo/skuId/{id} 根据skuId查询spu信息

6、订单服务编写 /submitOrder接口
远程调用库存服务 获取运费和收货人信息
远程调用购物车服务 获取当前购物车中购物项数据
远程调用商品服务获 根据skuId查询spu信息
最后完成提交订单
````
# 九、锁定库存
````
1、商品服务新建 WareSkuLockVo

2、复制商品服务 OrderItemVo、WareSkuLockVo 到库存服务

3、库存服务新建 LockStockResult

4、公共服务 新增自定义异常 NoStockException

5、BizCodeEnum 新增

6、库存服务 写/ware/waresku/lock/order 锁定库存

7、订单服务继续编写 /submitOrder接口
远程调用库存服务 锁定库存
最后完成锁定库存
````
# 十、分布式事务
````
1、修改conf目录下的application.yml配置文件, 修改seata的config和registry

2、nacos添加配置文件 seata.properties

3、创建seata库, 执行 seata/script/server/db目录下对应数据库的sql脚本

4、进入seata/bin目录
执行 seata-server.bat

5、每个微服务的数据库, 建回滚日志表 undo_log

6、引入依赖
<!-- 注意一定要引入对版本，要引入spring-cloud版本seata，而不是springboot版本的seata-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
    <!-- 排除掉springcloud默认的seata版本，以免版本不一致出现问题-->
    <exclusions>
        <exclusion>
            <groupId>io.seata</groupId>
            <artifactId>seata-spring-boot-starter</artifactId>
        </exclusion>
        <exclusion>
            <groupId>io.seata</groupId>
            <artifactId>seata-all</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<!-- 上面排除掉了springcloud默认色seata版本，此处引入和seata-server版本对应的seata包-->
<dependency>
    <groupId>io.seata</groupId>
    <artifactId>seata-spring-boot-starter</artifactId>
    <version>1.6.1</version>
</dependency>

7、添加seata配置
seata:
  tx-service-group: mygroup # 事务分组名称，要和服务端对应
  service:
    vgroup-mapping:
      mygroup: default # key是事务分组名称 value要和服务端的机房名称保持一致
````
# 十一、库存自动解锁
## 1、业务流程，订单失败后自动回滚解锁库存
````
seata不适合高并发场景, 使用消息队列

可靠消息+最终一致性方案
业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。
业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。
````
## 2、RabbitMQ环境准备
````
1、引入依赖
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>

2、yml配置RabbitMQ信息
spring:
   rabbitmq:
    host: 127.0.0.1
    port: 5672
    # 虚拟主机
    virtual-host: /
    # 开启发送端发送确认，无论是否到达broker都会触发回调【发送端确认机制+本地事务表】
    publisher-confirm-type: correlated
    # 开启发送端抵达队列确认，消息未被队列接收时触发回调【发送端确认机制+本地事务表】
    publisher-returns: true
    # 消息在没有被队列接收时是否强行退回
    template:
      mandatory: true
    # 消费者手动确认模式，关闭自动确认，否则会消息丢失
    listener:
      simple:
        acknowledge-mode: manual
        
3、主启动类添加注解@EnableRabbit

4、新建 MyGlobalRabbitConfig全局配置类

5、新建 MyRabbitMQConfig配置类

6、订单服务写测试接口 /test/createOrder

7、访问 http://order.gulimall.com/test/createOrder
````
## 3、解锁库存
````
1、订单取消和订单回滚。
下订单成功，订单过期没有支付被系统自动取消、被用户手动取消。都要解锁库存
下订单成功，库存锁定成功，接下来的业务调用失败，导致订单回滚;之前锁定的库存就要自动解锁

2、库存服务 引入依赖
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>

3、库存服务 yml配置RabbitMQ信息
spring:
   rabbitmq:
    host: 127.0.0.1
    port: 5672
    # 虚拟主机
    virtual-host: /
    # 开启发送端发送确认，无论是否到达broker都会触发回调【发送端确认机制+本地事务表】
    publisher-confirm-type: correlated
    # 开启发送端抵达队列确认，消息未被队列接收时触发回调【发送端确认机制+本地事务表】
    publisher-returns: true
    # 消息在没有被队列接收时是否强行退回
    template:
      mandatory: true
    # 消费者手动确认模式，关闭自动确认，否则会消息丢失
    listener:
      simple:
        acknowledge-mode: manual
        
4、库存服务 主启动类添加注解@EnableRabbit

5、库存服务新建 MyRabbitMQConfig配置类

6、wms_ware_order_task_detail 增加 ware_id和lock_status, 对应实体类添加字段

7、修改resources/mapper/ware/WareOrderTaskDetailDao.xml
<result property="wareId" column="ware_id"/>
<result property="lockStatus" column="lock_status"/>

8、公共服务新建给MQ传输的对象 StockLockedTo、StockDetailTo

9、修改库存服务 wareSkuService.oderLockStock 发送消息

10、订单服务新增 OrderVo实体类

11、订单模块修改拦截器 LoginUserInterceptor

12、订单服务写 /order/order/status/{orderSn}接口根据订单号查询订单

13、库存服务新增 监听器StockReleaseListener

14、库存服务新增 wareSkuService.unlockStock
远程调用订单服务 接口根据订单号查询订单
最终完成解锁库存
````
# 十二、定时关单
````
1、修改 MyRabbitMQConfig 订单释放直接和库存释放进行绑定

2、在订单创建成功时向MQ中 延时队列发送消息

3、公共服务新建 OrderTo

4、在订单的关闭之后时向MQ发送消息 解锁库存

5、订单服务创建 OrderCloseListener 监听订单死信队列

6、监听 stock.release.stock.queue 队列，解锁库存
````
