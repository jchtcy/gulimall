# 一、虚拟机
## 1、安装虚拟机
````
网上找, VMware虚拟机安装Ubuntu
````
## 2、虚拟机配置远程连接
### 1、Ubuntu 启动SSH服务
````
Ubuntu 启动SSH服务
sudo apt-get install openssh-server

检查SSH服务是否启动命令
ps -e |grep ssh
````
### 2、配置root登录
````
gedit /etc/ssh/sshd_config
在第34行添加 PermitRootLogin yes

命令重启ssh服务
service ssh restart
````
# 二、Docker安装
## 1、卸载旧版本
````
for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done
````
## 2、设置 Docker 的存储库
````
1、软件更新
sudo apt-get update
此时从乌班图官网更新软件失败

2、设置阿里云镜像
备份原来的源
sudo cp /etc/apt/sources.list /etc/apt/sources_init.list

更换源
sudo gedit /etc/apt/sources.list

更换为以下内容
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse

3、添加 Docker 的官方 GPG 密钥

sudo apt-get install ca-certificates curl gnupg
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg

4、将存储库添加到Apt源

echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
````
## 3、安装 Docker
````
1、安装Docker包
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

2、启动
sudo systemctl start docker

3、查看Docker的版本
docker version

4、通过运行映像来验证 Docker 引擎安装是否成功
sudo docker run hello-world

5、查看下载的 hello-world 镜像
docker images

6、开机启动docker
systemctl enable docker
````
## 4、卸载 Docker 引擎
````
1、下载依赖
sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras

2、删除资源
rm -rf /var/lib/docker
# /var/lib/docker docker的默认工作路径
````
## 5、Docker配置阿里云
````
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://f214zc7d.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
````
# 三、docker安装开发环境
## 1、docker中安装mysql
````
下载镜像: docker pull mysql:5.7

查看镜像: docker images

启动mysql: sudo docker run -p 3306:3306 --name mysql \
-v /mydata/mysql/log:/var/log/mysql \
-v /mydata/mysql/data:/var/lib/mysql \
-v /mydata/mysql/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=root \
-d mysql:5.7

修改配置: vi /mydata/mysql/conf/my.conf
[client]
default-character-set=utf8
[mysql]
default-character-set=utf8
[mysqld]
init_connect='SET collation_connection = utf8_unicode_ci'
init_connect='SET NAMES utf8'
character-set-server=utf8
collation-server=utf8_unicode_ci
skip-character-set-client-handshake
skip-name-resolve

重启容器使配置生效: docker restart mysql

mysql自动启动: docker update mysql --restart=always
````
## 2、docker中安装redis
````
下载镜像: docker pull redis

创建实例并启动: 
mkdir -p /mydata/redis/conf
touch /mydata/redis/conf/redis.conf
docker run -p 6379:6379 --name redis \
-v /mydata/redis/data:/data \
-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \
-d redis redis-server /etc/redis/redis.conf

数据持久化: 
vi /mydata/redis/conf/redis.conf
appendonly yes

重启redis使配置生效: docker restart redis

redis自动启动: docker update redis --restart=always
````
# 四、本地开发环境
## 1、idea
````
IDEA安装插件lombok，mybatisX。
IDEA设置里配置好maven
````
## 2、vsCode
````
Auto Close Tag
Auto Rename Tag
Chinese
HTML CSS Support
JavaScript ES6
Live Server
open in brower
Vetur
````
# 五、git
````
网上找, idea配置github提交项目代码
````
# 六、项目结构创建
## 1、新建github项目
````
仓库名gulimall
gitignore选中maven
许可证选Apache-2.0
创建两个分支: main(生产)和dev(开发)
````
## 2、从github上下拉项目
## 3、创建微服务模块
````
商品服务product
存储服务ware
订单服务order
优惠券服务coupon
用户服务member

导入web和openFeign
group：com.atguigu.gulimall
Artifact：gulimall-XXX
每一个服务，包名com.atguigu.gulimall.XXX{product/order/ware/coupon/member}
模块名：gulimall-XXX
````
## 4、父pom文件
````
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.atguigu.gulimall</groupId>
    <artifactId>gulimall</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>gulimall</name>
    <description>聚合服务</description>

    <packaging>pom</packaging>

    <modules>
        <module>gulimall-coupon</module>
        <module>gulimall-member</module>
        <module>gulimall-order</module>
        <module>gulimall-product</module>
        <module>gulimall-ware</module>
    </modules>

</project>
````
## 5、修改总项目的.gitignore, 加入以下内容
````
**/mvnw
**/mvnw.cmd
**/.mvn
**/target/
.idea
**/.gitignore
````
## 6、修改每个服务中spring boot和spring cloud的版本
````
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.2.RELEASE</version>
    <relativePath   />
</parent>

<properties>
    <java.version>1.8</java.version>
    <spring-cloud.version>Hoxton.SR6</spring-cloud.version>
</properties>
````
# 七、数据库
````
创建数据库分别运行sql下的脚本
````
# 八、人人开源搭建后台管理系统
## 1、后端
````
1、下载项目
git clone https://gitee.com/renrenio/renren-fast.git

2、在父pom文件中添加
<module>renren-fast</module>

3、renren-fast的pom文件修改为
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.2.RELEASE</version>
    <relativePath   />
</parent>

4、创建gulimall_admin数据库, 运行gulimall_admin.sql

5、修改application-dev.yml中的数库库的url
url: jdbc:mysql://192.168.48.129:3306/gulimall_admin?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
username: root
password: root

6、启动项目报错:
java: 找不到符号
  符号:   方法 allowedOriginPatterns(java.lang.String)
  位置: 类 org.springframework.web.servlet.config.annotation.CorsRegistration
将allowedOriginPatterns换成allowedOrigins

7、此时启动renren-fast,访问http://localhost:8080/renren-fast/
得到{“msg”:“invalid token”,“code”:401}就代表无误
````
## 2、前端
````
1、安装nvm管理nodejs版本, 本项目用10.16.3

2、安装node10.16.3

3、切换国内镜像源 npm config set registry https://registry.npmmirror.com

4、下载前端项目: git clone https://gitee.com/renrenio/renren-fast-vue.git

5、下载文件https://cdn.npm.taobao.org/dist/chromedriver/2.27/chromedriver_win32.zip

6、执行: npm install chromedriver --chromedriver_filepath=D:\安装包\chromedriver_win32.zip

7、修改项目文件 package.json 中的 saas 版本（不用太高也不能太低）
"node-sass": "4.13.1",
"sass-loader": "7.3.1",

10、安装依赖: npm install

11、启动项目: npm run dev

12、访问 http://localhost:8001/#/login 成功
````
## 3、代码生成器
````
1、下载代码: git clone https://gitee.com/renrenio/renren-generator.git

2、在父pom文件中添加
<module>renren-generator</module>

3、renren-fast的pom文件修改为
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.2.RELEASE</version>
    <relativePath   />
</parent>
````
## 4、使用代码生成器生成代码(以product模块为例, 其他模块类似)
````
1、修改代码生成器模块下 application-dev.yml中的数库库的url
url: jdbc:mysql://192.168.48.129:3306/gulimall_pms?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
username: root
password: root

2、修改generator.properties
#代码生成器，配置信息
mainPath=com.jch
#包名
package=com.jch.gulimall
moduleName=product
#作者
author=jch
#Email
email=jch@gulimall.com
#表前缀(类名不会包含表前缀)
tablePrefix=pms_

3、将生成的代码放到product

4、此时缺少一些依赖, 创建common模块

5、修改gulimall-common的pom文件
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>gulimall</artifactId>
        <groupId>com.atguigu.gulimall</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>gulimall-common</artifactId>
    <description>公共模块</description>

    <dependencies>
        <!-- mybatisPLUS-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.3.2</version>
        </dependency>
        <!--简化实体类，用@Data代替getset方法-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.8</version>
        </dependency>
        <!-- httpcomponent包。发送http请求 -->
        <dependency>
            <groupId>org.apache.httpcomponents</groupId>
            <artifactId>httpcore</artifactId>
            <version>4.4.13</version>
        </dependency>
        <dependency>
            <groupId>commons-lang</groupId>
            <artifactId>commons-lang</artifactId>
            <version>2.6</version>
        </dependency>
    </dependencies>
</project>

6、在product项目中的pom.xml中加入下面内容，作为common的子项目
<dependency>
    <groupId>com.jch.gulimall</groupId>
    <artifactId>gulimall-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>

7、将需要的工具类从io/renren/common 复制到 java/com/jch/common下

8、注释掉shiro相关代码
````
## 5、整合mybatisplus(以product模块为例, 其他模块类似)
````
1、在common的pom.xml中导入
<!-- 数据库驱动 https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.17</version>
</dependency>
<!--tomcat里一般都带-->
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>servlet-api</artifactId>
    <version>2.5</version>
    <scope>provided</scope>
</dependency>

2、在product项目的resources目录下新建application.yml
spring:
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.48.129:3306/gulimall_pms?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
    driver-class-name: com.mysql.jdbc.Driver

# MapperScan
# sql映射文件位置
mybatis-plus:
  mapper-locations: classpath:/mapper/**/*.xml
  global-config:
    db-config:
      id-type: auto

server:
  port: 10000

      
3、然后在主启动类上加上注解@MapperScan()
@MapperScan("com.jch.gulimall.product.dao")

4、运行测试类, 往数据库添加数据
@SpringBootTest
class GulimallProductApplicationTests {

    @Autowired
    BrandService brandService;

    @Test
    void contextLoads() {
        BrandEntity brandEntity = new BrandEntity();
        brandEntity.setName("华为");
        brandService.save(brandEntity);
        System.out.println("保存成功");
    }

}
````
## 6、参照product, 生成其他微服务的代码
````
端口号:
coupon: 7000
member: 8000
order: 9000
product: 10000
ware: 11000
````
# 九、SpringCloud Alibaba
## 1、简介
````
SpringCloud Alibaba - Nacos: 注册中心(服务注册)
SpringCloud Alibaba - Nacos: 配置中心(动态配置管理)
SpringCloud - Ribbon: 负载均衡
SpringCloud - Feign: 声明式HTTP客户端(调用远程服务)
SpringCloud Alibaba - Sentinel: 服务容错(限流、降级、熔断)
SpringCloud - Gateway: API网关(webflux编程模式)
SpringCloud - Sleuth: 调用链监控
SpringCloud Alibaba - Seata: 分布式事务

Spring Boot Version 2.3.2.RELEASE
Spring Cloud Version Hoxton.SR6
Spring Cloud Alibaba Version 2.2.1.RELEASE
````
## 2、引入
````
在common的pom.xml中加入

<dependencyManagement>
    <dependencies>
        <!-- Spring Cloud Alibaba-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
            <version>2.2.1.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
````
# 十、Nacos注册中心
## 1、nacos(1.1.3版本)安装
````
下载: https://github.com/alibaba/nacos/releases
启动: 双击bin/startup.cmd
访问: http://127.0.0.1:8848/nacos/
````
## 2、导入依赖
````
放到common里

<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
````
## 3、微服务注册到nacos(以coupon为例)
````
启动类添加注解
@EnableDiscoveryClient

修改application.yml文件, 配置注册中心地址和当前应用名
    cloud:
        nacos:
          discovery:
            server-addr: 127.0.0.1:8848
    application:
        name: gulimall-coupon
````
# 十一、Feign远程调用
## 1、引入依赖
````
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
````
## 2、例: member调用coupon
````
1、在coupon中修改如下的内容
@RequestMapping("coupon/coupon")
public class CouponController {
    @Autowired
    private CouponService couponService;

    @RequestMapping("/member/list")
    public R membercoupons(){    //全系统的所有返回都返回R
        // 应该去数据库查用户对于的优惠券，但这个我们简化了，不去数据库查了，构造了一个优惠券给他返回
        CouponEntity couponEntity = new CouponEntity();
        couponEntity.setCouponName("满100-10");//优惠券的名字
        return R.ok().put("coupons",Arrays.asList(couponEntity));
    }
}

2、在member的com.jch.gulimall.member包下新建类 feign.CouponFeignService
@FeignClient("gulimall-coupon") //告诉spring cloud这个接口是一个远程客户端，要调用coupon服务(nacos中找到)，具体是调用coupon服务的/coupon/coupon/member/list对应的方法
public interface CouponFeignService {
    // 远程服务的url
    @RequestMapping("/coupon/coupon/member/list")//注意写全优惠券类上还有映射//注意我们这个地方不是控制层，所以这个请求映射请求的不是我们服务器上的东西，而是nacos注册中心的
    public R membercoupons();//得到一个R对象
}

3、在启动类上加: @EnableFeignClients(basePackages="com.jch.gulimall.member.feign")//扫描接口方法注解

4、在member的控制层写一个测试请求
@Autowired
CouponFeignService couponFeignService;

@RequestMapping("/coupons")
public R test(){
    MemberEntity memberEntity = new MemberEntity();
    memberEntity.setNickname("会员昵称张三");
    R membercoupons = couponFeignService.membercoupons();//假设张三去数据库查了后返回了张三的优惠券信息

    //打印会员和优惠券信息
    return R.ok().put("member",memberEntity).put("coupons",membercoupons.get("coupons"));
}

5、重启服务测试: http://localhost:8000/member/member/coupons
{
    "msg": "success",
    "code": 0,
    "coupons": [
        {
            "id": null,
            "couponType": null,
            "couponImg": null,
            "couponName": "满100-10",
            "num": null,
            "amount": null,
            "perLimit": null,
            "minPoint": null,
            "startTime": null,
            "endTime": null,
            "useType": null,
            "note": null,
            "publishCount": null,
            "useCount": null,
            "receiveCount": null,
            "enableStartTime": null,
            "enableEndTime": null,
            "code": null,
            "memberLevel": null,
            "publish": null
        }
    ],
    "member": {
        "id": null,
        "levelId": null,
        "username": null,
        "password": null,
        "nickname": "会员昵称张三",
        "mobile": null,
        "email": null,
        "header": null,
        "gender": null,
        "birth": null,
        "city": null,
        "job": null,
        "sign": null,
        "sourceType": null,
        "integration": null,
        "growth": null,
        "status": null,
        "createTime": null,
        "socialUid": null,
        "accessToken": null,
        "expiresIn": null
    }
}
````
# 十二、nacos配置中心
## 1、引入依赖
````
common中添加依赖 nacos配置中心
<dependency>
     <groupId>com.alibaba.cloud</groupId>
     <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
````
## 2、微服务读取nacos上的配置(以coupon为例)
````
1、在coupons项目中创建/src/main/resources/bootstrap.properties ，这个文件是springboot里规定的，他优先级别application.properties高
spring.application.name=gulimall-coupon #当前应用名
spring.cloud.nacos.config.server-addr=127.0.0.1:8848 #nacos配置中心地址

2、CouponController中加入测试接口
@Value("${coupon.user.name}")
private String name;

@Value("${coupon.user.age}")
private String age;

@RequestMapping("/test")
public R test() {
    return R.ok().put("name", name).put("age", age);
}

3、nacos添加配置, Data ID: gulimall-coupon.properties
coupon.user.name=配置中心   
coupon.user.age=12

4、访问: http://localhost:7000/coupon/coupon/test
{
    "msg": "success",
    "code": 0,
    "name": "配置中心",
    "age": "12"
}

5、此时将coupon.user.age修改为20, 刷新页面发现coupon.user.age还是12

6、在CouponController上加@RefreshScope, 此时能动态读取配置了
````
## 3、nacos的配置内容优先于项目本地的配置内容。
## 4、配置中心进阶
````
命名空间：用作配置隔离。(一般每个微服务一个命名空间)
    1、默认public。默认新增的配置都在public空间下
    2、开发、测试、开发可以用命名空间分割。properties每个空间有一份。也可以为每个微服务配置一个命名空间，微服务互相隔离
        # 在bootstrap.properties里写上对应环境的命名空间ID(测试完去掉，学习不需要)
        spring.cloud.nacos.config.namespace=b176a68a-6800-4648-833b-be10be8bab00
    3、为每一个微服务创建命名空间, 只加载自己命名空间下的所有配置
    
配置集: 一组相关或不相关配置项的集合

配置集ID: 类似于配置文件名，即Data ID

配置分组: 默认所有的配置集都属于DEFAULT_GROUP
````
## 5、最终方案: 每个微服务创建自己的命名空间，然后使用配置分组区分环境（dev/test/prod）
## 6、加载多配置集
````
1、nacos中新建三个配置文件, 命名空间: coupon, 分组: dev
datasource.yml, mybatis.yml, other.yml

2、将application.yml里内容注释掉

3、bootstrap.properties中添加内容
spring.application.name=gulimall-coupon

spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.namespace=aff10634-a4ec-4b2a-a7d6-cece842582db
spring.cloud.nacos.config.group=dev

spring.cloud.nacos.config.extension-configs[0].data-id=datasource.yml
spring.cloud.nacos.config.extension-configs[0].group=dev
spring.cloud.nacos.config.extension-configs[0].refresh=true

spring.cloud.nacos.config.extension-configs[1].data-id=mybatis.yml
spring.cloud.nacos.config.extension-configs[1].group=dev
spring.cloud.nacos.config.extension-configs[1].refresh=true

spring.cloud.nacos.config.extension-configs[2].data-id=other.yml
spring.cloud.nacos.config.extension-configs[2].group=dev
spring.cloud.nacos.config.extension-configs[2].refresh=true

4、重启“gulimall-coupon”服务，然后访问：http://localhost:7000/coupon/coupon/test

5、访问：http://localhost:7000/coupon/coupon/list，查看是否能够正常的访问数据库
````
# 十三、网关gateway
## 1、创建gateway模块
````
创建微服务，使用initilizer，
Group：com.jch.gulimall，
Artifact： gulimall-gateway，
package：com.jch.gulimall.gateway。 
搜索gateway选中。
````
## 2、修改gateway模块的pom文件
````
加上common依赖
修改springboot版本
修改springcloud版本
修改jdk版本
````
## 3、开启服务注册发现
````
主启动类添加: @EnableDiscoveryClient

配置nacos注册中心地址applicaion.properties
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
spring.application.name=gulimall-gateway
server.port=88
````
## 4、nacos中新建gateway的命名空间
## 5、bootstrap.properties 填写nacos配置中心地址
````
spring.application.name=gulimall-gateway

spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.namespace=10292e60-ac90-4d3a-b934-f0b592b749cf
````
## 5、nacos中新建gulimall-gateway.yml
````
spring:
    application:
        name: gulimall-gateway
````
## 6、启动项目报错: Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.
````
主启动类排除数据源
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
````
## 7、在项目里创建application.yml，根据条件转发到uri
````
spring:
  cloud:
    gateway:
      routes:
        # 如果请求参数url等于百度, 则跳转到https://www.baidu.com
        - id: baidu_route
          uri: https://www.baidu.com
          predicates:
            - Query=url, baidu
        # 如果请求参数url等于qq, 则跳转到https://www.qq.com
        - id: qq_route
          uri: https://www.qq.com
          predicates:
            - Query=url, qq
            
访问: http://localhost:88/?url=baidu 或 http://localhost:88/?url=qq
````
# 十四、前端基础
## 1、快捷键：！+ Enter生成模板
## 2、ES6(ECMAScript6.0)
### 1、let
````
let声明后不能作用于{}外，var可以

let只能声明一次，var可以声明多次

var会变量提升（使用在定义之前），let必须先定义再使用
````
### 2、const
````
const一旦初始化后，不能改变
````
### 3、解构表达式
````
数组解构let arr = [1,2,3]; let [a,b,c] = arr

对象解构const{name:abc, age, language} = person 其中name:abc代表把name改名为abc
````
### 4、字符串拓展
````
字符串函数str.startsWith();str.endsWith();str.includes();

字符串模板，``支持一个字符串定义为多行
let ss = `<div>
                    <span>hello world<span>
                </div>`;

占位符功能 ${}
````
### 5、函数优化
````
支持函数形参默认值 function add(a, b = 1){}

支持不定参数 function fun(...values){}

支持箭头函数(类似于lomda表达式) var print = obj => console.log(obj);

支持箭头函数+解构函数 var hello2 = ({name}) => console.log("hello," +name); hello2(person);
````
### 6、对象优化
````
可以获取map的键值对Object.keys()、Object.values、Object.entries

Object.assgn(target,source1,source2) 合并source1，source2到target

支持对象名声明简写：如果属性名和属性值的变量名相同可以省略
const age = 23
const name = "张三"
const person1 = { age: age, name: name }
// 等价于
const person2 = { age, name }//声明对象简写

对象的函数属性简写
let person3 = {
    name: "jack",
    // 以前：
    eat: function (food) {
        console.log(this.name + "在吃" + food);
    },
    //箭头函数this不能使用，要使用的话需要使用：对象.属性
    eat2: food => console.log(person3.name + "在吃" + food),
    eat3(food) {
        console.log(this.name + "在吃" + food);
    }
}
person3.eat("香蕉");
person3.eat2("苹果")
person3.eat3("橘子");

let someone = {...person}取出person对象所有的属性拷贝到当前对象
// 1、拷贝对象（深拷贝）
let p1 = { name: "Amy", age: 15 }
let someone = { ...p1 }
console.log(someone)  //{name: "Amy", age: 15}

// 2、合并对象, 后面的值覆盖前面的值
let age1 = { age: 15 }
let name1 = { name: "Amy" }
let p2 = { name: "zhangsan" }
p2 = { ...age1, ...name1 }
console.log(p2)
````
### 7、map和reduce
````
arr.map()接收一个函数，将arr中的所有元素用接收到的函数处理后放入新的数组

arr.reduce()为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，
let result = arr.reduce((a, b) => {
    console.log("上一次处理后：" + a);
    console.log("当前正在处理：" + b);
    return a + b;
}, 100);
````
### 8、promise
````
优化异步操作。封装ajax
把Ajax封装到Promise中，赋值给let p
在Ajax中成功使用resolve(data)，失败使用reject(err)
p.then().catch()

function get(url, data) {
    return new Promise((resolve, reject) => {
        $.ajax({
            url: url,
            data: data,
            success: function (data) {
                resolve(data);
            },
            error: function (err) {
                reject(err)
            }
        })
    });
}

get("mock/user.json")
    .then((data) => {
        console.log("用户查询成功~~~:", data)
        return get(`mock/user_corse_${data.id}.json`);
    })
    .then((data) => {
        console.log("课程查询成功~~~:", data)
        return get(`mock/corse_score_${data.id}.json`);
    })
    .then((data)=>{
        console.log("课程成绩查询成功~~~:", data)
    })
    .catch((err)=>{
        console.log("出现异常",err)
    });
````
### 9、模块化
````
export用于规定模块的对外接口,export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象
import用于导入其他模块提供的功能

// user.js

var name = "jack"
var age = 21
function add(a,b){
    return a + b;
}
// 导出变量和函数
export {name,age,add}

---------------------------------------------------------------
// hello.js
    
// 导出后可以重命名
export default {
    sum(a, b) {
        return a + b;
    }
}


--------------------------------------------------------------
// main.js

import abc from "./hello.js"
import {name,add} from "./user.js"

abc.sum(1,2);
console.log(name);
add(1,3);
````
## 3、vue基础和ElementUI跳过
# 十五、商品服务API
## 1、三级分类
### 1、查询分类维护-递归树形结构获取
````
1、先把数据导入表pms_category，数据库文件sql/pms_catelog.sql

2、编写后端代码, 查出所有分类以及子分类, 以树形结构组装
````
### 2、三级分类的前端
````
1、启动renren-fast和renren-fast-vue

2、新增目录,
类型: 目录
目录名称: 商品系统
上级菜单: 一级菜单

3、新增菜单
菜单名称: 分类维护
上级菜单: 商品系统
菜单路由: product/category

4、前端路由规则
url: http://localhost:8001/#/product-category
填写的菜单路由: product/category
对应的视图: src/view/modules/product/category.vue
如果我们要自定义product/category视图的话，就要创建src/view/mudules/product/category.vue

5、直接复制别人的vue文件

6、此时发送请求, 他是给8080端口发的请求，而我们的商品服务在10000端口。
我们以后还会同时发向更多的端口，所以需要配置网关，前端只向网关发送请求，然后由网关自己路由到相应端口。

7、让前端向网关发送端口
修改static/config/index.js
// api接口请求地址
window.SITE_CONFIG['baseUrl'] = 'http://localhost:88/api';
  
8、刷新，发现验证码出不来。前端给网关发验证码请求，但是验证码请求在renren-fast服务里。

9、把renren-fast服务注册到服务中心。

10、网关进行路由。
- id: admin_route
  uri: lb://renren-fast
  predicates:
    - Path=/api/**  #把所有api开头的请求都转发给renren-fast
  filters:
    # 默认规则， 请求过来：http://localhost:88/api/captcha.jpg   转发-->  http://renren-fast:8080/api/captcha.jpg
    # 但是真正的路径是http://renren-fast:8080/renren-fast/captcha.jpg
    # 所以使用路径重写把/api/* 改变成 /renren-fast/*
    - RewritePath=/api/(?<segment>.*),/renren-fast/$\{segment}

11、此时验证码报错503, gateway引入loadbalancer
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>

12、此时测试, 出现跨域问题    
````
### 3、解决跨域问题
````
解决办法1: 使用nginx部署为同一域

解决方法2: 配置当次请求允许跨域(开发期间使用)
在gulimall-gateway中新建配置类
@Configuration
public class MyCorsConfiguration {

    @Bean
    public CorsWebFilter corsWebFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();

        CorsConfiguration corsConfiguration = new CorsConfiguration();
        // 配置跨域
        // 允许跨域的头
        corsConfiguration.addAllowedHeader("*");
        // 允许跨域的请求方式
        corsConfiguration.addAllowedMethod("*");
        // 允许跨域的请求来源
        corsConfiguration.addAllowedOrigin("*");
        // 是否允许携带cookie跨域
        corsConfiguration.setAllowCredentials(true);

        // 任意url都要进行跨域配置
        source.registerCorsConfiguration("/**",corsConfiguration);
        return new CorsWebFilter(source);
    }
}

注释掉renren-fast/src/main/java/io.renren/config/CorsConfig之中的跨域
成功解决跨域问题，登录到后台管理界面
````
### 4、查询分类维护-网关转发
````
把gulimall-product服务注册到服务中心。

网关进行路由, 精确的路由要放在上面
- id: admin_route
  uri: lb://renren-fast
  predicates:
    - Path=/api/**  #把所有api开头的请求都转发给renren-fast
  filters:
    # 默认规则， 请求过来：http://localhost:88/api/captcha.jpg   转发-->  http://renren-fast:8080/api/captcha.jpg
    # 但是真正的路径是http://renren-fast:8080/renren-fast/captcha.jpg
    # 所以使用路径重写把/api/* 改变成 /renren-fast/*
    - RewritePath=/api/(?<segment>.*),/renren-fast/$\{segment}
````
### 5、删除
````
1、前端直接复制

2、后端逻辑删除

3、修改product模块的application.yml
# MapperScan
# sql映射文件位置
mybatis-plus:
  mapper-locations: classpath:/mapper/**/*.xml
  global-config:
    db-config:
      id-type: auto
      logic-delete-value: 0
      logic-not-delete-value: 1
      
4、实体类字段上加上@TableLogic(value = "1", delval = "0")注解，
三级分类把showStatus字段作为逻辑删除字段

5、可以打印日志,在配置文件中修改日志级别, 修改product模块的application.yml
logging:
  level:
    com.jch.gulimall.product: debug
````
### 6、新增
````
1、前端直接复制别人的vue文件

2、后端用代码生成的

3、启动测试
````
### 7、基本修改
````
1、前端直接复制别人的vue文件

2、后端用代码生成的

3、启动测试
````
### 8、拖拽修改
````
1、前端直接复制别人的vue文件

2、后端编写保存拖拽修改的代码

3、启动测试
````
### 9、批量删除功能
````
1、前端直接复制别人的vue文件

2、后端用代码生成的

3、启动测试
````
## 2、品牌管理
